#+TITLE: Reproducing Spectre Attack with gem5, How To Do It Right?
#+AUTHOR: Pierre Ayoub
#+EMAIL: pierre.ayoub@eurecom.fr
#+LANGUAGE: en
#+PROPERTY: header-args :eval never-export
#+HTML_HEAD: <link rel="stylesheet" href="https://sandyuraz.com/styles/org.min.css">

* Introduction

  This web page is linked to the /[[https://github.com/pierreay/reproduce-spectre-gem5/blob/main/docs/paper.pdf][Reproducing Spectre Attack with gem5, How To
  Do It Right?]]/ paper, as well with the /[[https://github.com/pierreay/reproduce-spectre-gem5/blob/main/docs/master_thesis.pdf][Simulating Transient Execution Attacks
  with gem5]]/ master thesis.

  It will guide you through the reproduction of the experiments, the usage of
  our implementations or through the demonstration of some techniques discussed
  in the paper. You can navigate with the table of content, or directly click
  below to:
  - [[#howto_spectre][Learn how to perform a Spectre attack with our implementation]]
  - [[#howto_spectre][Learn how to simulate Spectre with gem5]]
  - [[#howto_konata][Learn how to visualize the pipeline of a simulated processor with Konata]]

* Repository

  This web page is part of the repository located [[https://github.com/pierreay/reproduce-spectre-gem5][here]]. See the =README.md=
  file for repository organization and navigation.

* HowTo

** How to Setup the Native ARM System
   :PROPERTIES:
   :CUSTOM_ID: setup_arm
   :END:

   To reproduce this work, you will need:
   - An ARM board. We used a [[https://static.raspberrypi.org/files/product-briefs/200521+Raspberry+Pi+4+Product+Brief.pdf][Raspberry Pi v4 Model B Rev 1.1]] embedding a [[http://infocenter.arm.com/help/topic/com.arm.doc.100095_0003_06_en/cortex_a72_mpcore_trm_100095_0003_06_en.pdf][ARM
     Cortex-A72]] (ARMv8-A) processor implemented in a SoC [[https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711/rpi_DATA_2711_1p0.pdf][Broadcom BCM2711]].
   - A 64-bit operating system (kernel and userland) for ARM. We used [[https://www.offensive-security.com/kali-linux-arm-images/][Kali
     Linux]] (stable v2020.2a, with a Linux kernel v4.19.118-Re4son-v8l+ and a
     GCC compiler v9.3), because:
     1. It is a full 64-bit operating system supporting ARM,
     2. The kernel is nearly the same as the one provided by gem5,
     3. The kernel sources and headers are available with =apt= (for developing
        kernel modules, if you do so).

   Install the Kali Linux distribution. First, download the image:

   #+BEGIN_SRC bash :eval never
   cd /tmp
   zip="kali.xz"
   img="kali.img"
   wget -O "$zip" https://images.offensive-security.com/arm-images/kali-linux-2020.2a-rpi3-nexmon-64.img.xz
   xzcat "$zip" > "$img"
   rm -f "$zip"
   #+END_SRC

   Then, insert your SD card in your computer, and make sure that device block
   name is correct (find it with =lsblk= and =umount= it if it has been
   automatically mounted). Bit-copy the image on the SD card:

   #+BEGIN_SRC bash :eval never
   sdcard=/dev/sdd
   sudo dd bs=4M if="$img" of="$sdcard" status=progress conv=fsync
   rm -f "$img"
   #+END_SRC

   Now, plug the SD card in the Raspberry Pi, plug an Ethernet cable and plug
   the power cable in it. Then, find the IP address associated to it and
   connect with the =kali= login and =kali= password:

   #+BEGIN_SRC bash
   ip="192.168.1.1" # Find the correct IP.
   ssh kali@$ip
   # We install the following software:
   sudo apt-get update && sudo apt-get upgrade
   sudo apt-get -y install linux-cpupower git
   #+END_SRC

   You can log in the =root= account by issuing the command =sudo su root= if
   needed.

   You are now ready to reproduce Spectre on the Raspberry Pi.
   
** How to Perform the Spectre Attack
   :PROPERTIES:
   :CUSTOM_ID: howto_spectre
   :END:

   We assume that you are on the ARM system described in Section [[#setup_arm]] or
   an equivalent one.

   First, clone the repository:

   #+BEGIN_SRC bash :eval never
   git clone https://github.com/pierreay/reproduce-spectre-gem5
   # We will use this variable to designate the repository through the hole file.
   reproducing_repo="$(pwd)"/reproduce-spectre-gem5
   cd "$reproducing_repo"
   #+END_SRC

   Simply use the =Makefile= to compile our implementation, described in
   Section [[#implem_spectre]]:
    
   #+BEGIN_SRC bash :eval never
   cd spectre && make
   #+END_SRC

   Test if the binary is working by displaying a useful help message:

   #+BEGIN_SRC bash :eval never
   ./spectre --help
   #+END_SRC

   #+BEGIN_EXAMPLE
   Usage: spectre [OPTION...]
   Spectre -- A Spectre implementation useful for research

     -c, --cache_threshold=NUMBER   Cache threshold separating hit and miss
                                (default: automatically computed)
     -l, --loops=NUMBER         Number of loops (training and attack) per attempts
                                (default: 30)
     -m, --meta=NUMBER          Number of meta-repetition of Spectre (default: 1)
     -q, -s, --quiet, --silent  Don't produce the header for csv
     -t, --tries=NUMBER         Number of attempts to guess a secret byte
                                (default: 999)
     -v, --verbose              Produce verbose output
     -?, --help                 Give this help list
         --usage                Give a short usage message
     -V, --version              Print program version

   Mandatory or optional arguments to long options are also mandatory or optional
   for any corresponding short options.

   Report bugs to <pierre.ayoub@irisa.fr>.
   #+END_EXAMPLE
    
   And test the attack with the default parameters like this:

   #+BEGIN_SRC bash :eval never
   ./spectre 
   #+END_SRC

   If it works correctly, you surely want to generate the metrics as we do in
   the paper and customize some parameters. The metrics will be generated in a
   =csv= format, you can then redirect them to a file. To do so, we use this
   loop to repeat the hole experiment. We first launch one experiment, and
   relaunch the others with the =-q= flag to suppress header line:

   #+BEGIN_SRC bash :eval never
   # Parameters.
   runs=50 # Number of runs - 1.
   m=10    # Number of meta repetition in the binary itself.
   t=999   # Number of attempts to guess one byte.
   l=100   # Number of loop per attempt.
   # Runs.
   ./spectre/spectre -m $m -l $l -t $t
   for (( i = 1; i < $runs; i++ ))
   do  
       ./spectre/spectre -q -m $m -l $l -t $t   
   done
   #+END_SRC

   *Optional*. If you want to obtain the =perf_event= metrics under a gem5
   simulation, you will have to recompile the Spectre binary with a patch. This
   is still a =TODO= item in the source code. To do that, use =git-apply= to
   apply the patch, save the previously compiled binary with another name and
   relaunch =make=:

    #+BEGIN_SRC bash :eval never
    # Apply the patch
    cd "$reproduce_repo"
    git apply spectre/perf.c.patch
    # Save the previous binary
    cd spectre
    mv spectre spectre_native
    # Compile the new Spectre
    make
    #+END_SRC

    #+BEGIN_SRC diff :tangle ../spectre/perf.c.patch :exports none
    diff --git i/spectre/perf.c w/spectre/perf.c
    index 3b89ee7..c648e28 100644
    --- i/spectre/perf.c
    +++ w/spectre/perf.c
    @@ -39,9 +39,9 @@ static int perf_fd_branch_miss;
    static void perf_attr_init(struct perf_event_attr * attr, uint64_t config)
    {
    /* To use with real ARM hardware: */
    -    attr->type = PERF_TYPE_HARDWARE;
    +    // attr->type = PERF_TYPE_HARDWARE;
    /* To use with gem5 full-system ARM: */
    -    // attr->type = PERF_TYPE_RAW;
    +    attr->type = PERF_TYPE_RAW;
    attr->config = config;
    attr->size = sizeof(*attr);
    attr->exclude_kernel = 1;
    @@ -53,9 +53,9 @@ void perf_init() {
    /* Initialize our perf_event_attr, representing one counter to be read. */
    static struct perf_event_attr attr_cache_miss;
    /* To use with real ARM hardware: */
    -    perf_attr_init(&attr_cache_miss, PERF_COUNT_HW_CACHE_MISSES);
    +    // perf_attr_init(&attr_cache_miss, PERF_COUNT_HW_CACHE_MISSES);
    /* To use with gem5 full-system ARM: */
    -    // perf_attr_init(&attr_cache_miss, 0x33);
    +    perf_attr_init(&attr_cache_miss, 0x33);
    /* Open the file descriptor corresponding to this counter. The counter
    should start at this moment. */
    if ((perf_fd_cache_miss = syscall(__NR_perf_event_open, &attr_cache_miss, 0, -1, -1, 0)) == -1)
    @@ -64,8 +64,8 @@ void perf_init() {
    /* Same here. */
    static struct perf_event_attr attr_branch_miss;
    /* To use with real ARM hardware: */
    -    perf_attr_init(&attr_branch_miss,PERF_COUNT_HW_BRANCH_MISSES);
    +    // perf_attr_init(&attr_branch_miss,PERF_COUNT_HW_BRANCH_MISSES);
    /* To use with gem5 full-system ARM: */
    -    // perf_attr_init(&attr_branch_miss, 0x10);
    +    perf_attr_init(&attr_branch_miss, 0x10);
    if ((perf_fd_branch_miss = syscall(__NR_perf_event_open, &attr_branch_miss, 0, -1, -1, 0)) == -1)
    fprintf(stderr, "perf_event_open fail %d %d: %s\n", perf_fd_branch_miss, errno, strerror(errno));
    }
    #+END_SRC

** How to Setup gem5 for a Full-System Simulation
   :PROPERTIES:
   :CUSTOM_ID: howto_gem5_setup
   :END:

   To reproduce this work, you will need:
   - A working [[https://www.gem5.org/getting_started/][gem5]] installation. We used gem5 v20.0.
   - An [[https://www.gem5.org/documentation/general_docs/fullsystem/guest_binaries][operating system image and a kernel image]] ready-to-use with gem5. We
     used the [[http://dist.gem5.org/dist/current/arm/disks/linaro-minimal-aarch64.img.bz2][64-bit Linaro Minimal v7.4.0 (based on Ubuntu)]] and the [[http://dist.gem5.org/dist/current/arm/aarch-system-201901106.tar.bz2][ARM64
     Linux kernel v4.18.0]] images provided by gem5's developers.

   Note that this gem5 version and the images are now obsolete. You can of
   course follow our steps, but then for a new research, it would be better to
   use the latest gem5 version and images with the new recommended methods
   (e.g., Docker container).

   First, install the recommended packages:

   #+BEGIN_SRC bash :eval never
   sudo apt install build-essential git m4 scons zlib1g zlib1g-dev \
       libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev \
       python3-dev python3-six python libboost-all-dev pkg-config
   #+END_SRC

   Clone the gem5 repository:

   #+BEGIN_SRC bash :eval never
   git clone https://gem5.googlesource.com/public/gem5
   # We will use this variable to designate the gem5 repository through the hole
   # file.
   gem5_repo="$(pwd)"/gem5
   cd "$gem5_repo"
   #+END_SRC

   Checkout the commit for version 20.0:

   #+BEGIN_SRC bash :eval never
   git checkout v20.0.0.0
   #+END_SRC

   *Optional*. If you want to obtain the =perf_event= metrics under a gem5
   simulation, you will have to apply a patch from our repository to the gem5
   source code to enable =perf_event= on the gem5 side (note that it should not
   be required on the latest gem5 version). To do that, use:

   #+BEGIN_SRC bash
   git apply "$reproduce_repo"/gem5/perf_event.patch
   #+END_SRC

   #+BEGIN_SRC diff :tangle ../gem5/perf_event.patch :exports none
   diff --git i/src/arch/arm/ArmISA.py w/src/arch/arm/ArmISA.py
   index 2641ec3fb..3d85c1b75 100644
   --- i/src/arch/arm/ArmISA.py
   +++ w/src/arch/arm/ArmISA.py
   @@ -36,6 +36,7 @@
   from m5.params import *
   from m5.proxy import *

   +from m5.SimObject import SimObject
   from m5.objects.ArmPMU import ArmPMU
   from m5.objects.ArmSystem import SveVectorLength
   from m5.objects.BaseISA import BaseISA
   @@ -49,6 +50,8 @@ class ArmISA(BaseISA):
   cxx_class = 'ArmISA::ISA'
   cxx_header = "arch/arm/isa.hh"

   +    generateDeviceTree = SimObject.recurseDeviceTree
   +
   system = Param.System(Parent.any, "System this ISA object belongs to")

   pmu = Param.ArmPMU(NULL, "Performance Monitoring Unit")
   diff --git i/src/arch/arm/ArmPMU.py w/src/arch/arm/ArmPMU.py
   index 047e908b3..58553fbf9 100644
   --- i/src/arch/arm/ArmPMU.py
   +++ w/src/arch/arm/ArmPMU.py
   @@ -40,6 +40,7 @@ from m5.params import *
   from m5.params import isNullPointer
   from m5.proxy import *
   from m5.objects.Gic import ArmInterruptPin
   +from m5.util.fdthelper import *

   class ProbeEvent(object):
   def __init__(self, pmu, _eventId, obj, *listOfNames):
   @@ -76,6 +77,17 @@ class ArmPMU(SimObject):

   _events = None

   +    def generateDeviceTree(self, state):
   +        node = FdtNode("pmu")
   +        node.appendCompatible("arm,armv8-pmuv3")
   +        # gem5 uses GIC controller interrupt notation, where PPI interrupts
   +        # start to 16. However, the Linux kernel start from 0, and used a tag
   +        # (set to 1) to indicate the PPI interrupt type.
   +        node.append(FdtPropertyWords("interrupts", [
   +            1, int(self.interrupt.num) - 16, 0xf04
   +        ]))
   +        yield node
   +
   def addEvent(self, newObject):
   if not (isinstance(newObject, ProbeEvent)
   or isinstance(newObject, SoftwareIncrement)):
   diff --git i/src/cpu/BaseCPU.py w/src/cpu/BaseCPU.py
   index ab70d1d7f..66a49a038 100644
   --- i/src/cpu/BaseCPU.py
   +++ w/src/cpu/BaseCPU.py
   @@ -302,6 +302,11 @@ class BaseCPU(ClockedObject):
   node.appendPhandle(phandle_key)
   cpus_node.append(node)

   +        # Generate nodes from the BaseCPU children (and don't add them as
   +        # subnode). Please note: this is mainly needed for the ISA class.
   +        for child_node in self.recurseDeviceTree(state):
   +            yield child_node
   +
   yield cpus_node

   def __init__(self, **kwargs):
   #+END_SRC

   And finally, compile it in optimized mode (=opt=), for the ARM architecture
   (=ARM=), with 8 cores and for Python 3. It can take several hours:

   #+BEGIN_SRC bash :eval never
   mode="opt"
   arch="ARM"
   cores=8
   py_version=3 
   scons PYTHON_CONFIG=python$py_version-config build/$arch/gem5.$mode -j $cores
   #+END_SRC

    If everything is working, you should be able to display the help of our
    simulation script:

    #+BEGIN_SRC bash :eval never
    build/ARM/gem5.opt -q "$reproduce_repo"/gem5/RPIv4.py --help   
    #+END_SRC

    #+BEGIN_EXAMPLE
    usage: RPIv4.py [-h] [-v] [--num-cores NUM_CORES] [--se] [--fs]
                    [--fs-kernel FS_KERNEL] [--fs-disk-image FS_DISK_IMAGE]
                    [--fs-workload-image FS_WORKLOAD_IMAGE]
                    [--fs-restore FS_RESTORE]
                    [se-command [se-command ...]]

    Raspberry Pi 4 Model B Rev. 1.1 - Syscall emulation & Full-system simulation
    Script based on a real Raspberry Pi system. It is shipped with a "reproduced"
    ARM Cortex-A72 CPU. The intended use is security research. It can be used both
    in system-call emulation or full-system simulation. For the full-system
    simulation mode only, first boot your system and create a checkpoint where the
    used CPU will be the atomic one. Only then, restore you system from your
    checkpoint, where the CPU used will be the detailed one. When passing
    filenames in arguments of the script, please be sure that your M5_PATH
    environment variable is set accordingly.

    positional arguments:
      se-command            Command(s) to run (multiples commands are assigned to
                            a dedicated core)

    optional arguments:
      -h, --help            show this help message and exit
      -v, --verbose         Print detailed information of what is done
      --num-cores NUM_CORES
                            Number of CPU cores (default = 1)
      --se                  Enable system-call emulation (must provide 'command'
                            positional arguments)
      --fs                  Enable full-system emulation (must provide '--fs-
                            kernel' and '--fs-disk-image' options)
      --fs-kernel FS_KERNEL
                            Filename of the Linux kernel to use in full-system
                            emulation (searched under '$M5_PATH/binaries'
                            directory)
      --fs-disk-image FS_DISK_IMAGE
                            Filename of the disk image containing the system to
                            instantiate in full-system emulation
      --fs-workload-image FS_WORKLOAD_IMAGE
                            Filename of the disk image containing the workload to
                            mount in full-system emulation
      --fs-restore FS_RESTORE
                            Path to a folder created by "m5 checkpoint" command to
                            use for restoration
    #+END_EXAMPLE
    
    Otherwise, check the [[https://pierreay.github.io/reproduce-spectre-gem5/gem5_errors.html#compilation][=docs/gem5_errors.html=]] file to see if the compilation
    error has already been encountered.
    
    Let's create the images you need to perform a full-system
    simulation. First, you have to download the operating system and the kernel
    images that you will use over our simulated hardware:

    #+BEGIN_SRC bash :eval never
    img_dir=img
    mkdir $img_dir && cd $img_dir
    # OS
    wget -O - http://dist.gem5.org/dist/current/arm/disks/linaro-minimal-aarch64.img.bz2 | bunzip2 > linaro-minimal-aarch64.img
    # Kernel
    wget -O - http://dist.gem5.org/dist/current/arm/aarch-system-201901106.tar.bz2 | tar xjv
    #+END_SRC

    Then, you will have to create a third =workload.img= image that will
    contain the file(s) that you want to use in your experiments. In order to
    do that, first create a 100MB zero file (you can change the size with the
    =count= parameter):

    #+BEGIN_SRC bash :eval never
    img=workload.img
    dd if=/dev/zero of=$img count=200K
    #+END_SRC

    Create a loopback device in order to access the image as a block device:

    #+BEGIN_SRC bash :eval never
    dev=$(sudo losetup -f)
    sudo losetup -fP $img
    #+END_SRC

    Create a DOS partition table and a primary partition on the entire image,
    then format the new created partition with the =ext4= file system:

    #+BEGIN_SRC bash :eval never
    echo "," | sudo sfdisk $dev
    sudo mke2fs "$dev"p1
    #+END_SRC
    
    Finally, you are done at modifying your image, detach it from the loopback
    device:

    #+BEGIN_SRC bash :eval never
    sudo losetup -d $dev
    #+END_SRC

    Now, you have a persistent file that will hold your files for the
    simulation. Define a function that will be used each time you need to
    update the image with new files (binaries, data...):

    #+BEGIN_SRC bash :eval never
    # $1: workload image name/path.
    # $*: list of files to copy.
    workload_update() {
        dev=$(sudo losetup -f)
        mnt=/mnt/workload
        # Get arguments.
        img="$1"
        shift
        # Create the mount folder and the loop device.
        sudo mkdir -p $mnt
        sudo losetup -fP "$img"
        # Mount the block device.
        sudo mount -o loop $dev $mnt
        # Copy files/folders.
        sudo cp -r -f -t $mnt $*
        # List the files to confirm.
        ls -alh $mnt
        # Unmount the image and freed the loop device.
        sudo umount $mnt
        sudo losetup -d $dev
    }
    #+END_SRC

    We will use this function later. All your 3 images will be mounted directly
    in the simulated system by gem5 itself, and the files in the workload image
    will be accessible in read/write. This is an efficient and handy way to
    communicate with a gem5 simulation.

** How to Simulate Spectre with gem5
   :PROPERTIES:
   :CUSTOM_ID: howto_gem5
   :END:

   We assume that you are able to compile and know how to perform a Spectre
   attack with our binary (at least in theory), described in Section
   [[#howto_spectre]].

   We assume that your gem5 setup is ready to perform a full-system simulation,
   described in Section [[#howto_gem5_setup]].

   *Boot*. The first step is to boot the system once, which can take up to one
   entire hour. You will launch the simulation of our system, described in
   Section [[#implem_gem5]], with gem5. Call gem5 with our Python script describing
   our system, declare 4 cores and the images for the full-system simulation
   with this command:

   #+BEGIN_SRC bash :eval never
   cd "$reproduce_repo"/gem5
   "$gem5_repo"/build/ARM/gem5.opt -q -d 01boot \
                                   ./RPIv4.py -v --num-cores=4 --fs \
                                   --fs-kernel="$gem5_repo"/"$img_dir"/vmlinux.arm64 \
                                   --fs-disk-image="$gem5_repo"/"$img_dir"/linaro-minimal-aarch64.img \
                                   --fs-workload-image="$gem5_repo"/"$img_dir"/"$img"
   #+END_SRC

   On another shell, launch the following command to connect to your simulation
   with =m5term= (which use =telnet=):
   
   #+BEGIN_SRC bash :evel never
   "$gem5_repo"/util/term/m5term localhost 3456
   #+END_SRC

   You must now see the boot process of the simulated system. Wait for the boot
   process to finish until you get a prompt, and then, issue the following
   command:

   #+BEGIN_SRC bash
   m5 checkpoint
   #+END_SRC

   This will create a snapshot of the running system just after the boot
   process in the =01boot/cpt.{ticknumber}= folder. Now, you will be able to
   restore the snapshot in a matter of second each time you want to simulate an
   experiment, there is no need to wait for the boot process anymore (except if
   you modify some parameters of the system in the Python files).

   You can terminate your simulation. Press =C-d= to disconnect from the
   terminal, and use the following command to kill gem5:

   #+BEGIN_SRC bash
   pkill gem5
   #+END_SRC

   *Spectre*. This time, you will be able to simulate the Spectre attack in a
   full-system simulation. First, copy the Spectre binary on the =workload.img=
   image. Use our predefined function (Section [[#howto_gem5_setup]]) for that:

   #+BEGIN_SRC bash :eval never
   cd "$reproduce_repo"
   workload_update "$gem5_repo"/"$img_dir"/"$img" spectre/spectre
   #+END_SRC

   You know have a ready =workload.img= image with the Spectre binary
   inside. The last step is to relaunch the simulation from the previous
   checkpoint:

   #+BEGIN_SRC bash
   "$gem5_repo"/build/ARM/gem5.opt -q -d 02restore \
                                      ./RPIv4.py -v --num-cores=4 --fs \
                                      --fs-kernel="$gem5_repo"/"$img_dir"/vmlinux.arm64 \
                                      --fs-disk-image="$gem5_repo"/"$img_dir"/linaro-minimal-aarch64.img \
                                      --fs-workload-image="$gem5_repo"/"$img_dir"/"$img" \
                                      --fs-restore=01boot/cpt.*
   #+END_SRC

   On another shell, you can connect to the restored simulation and wait
   reaching the prompt (a matter of seconds or 1-2 minutes):

   #+BEGIN_SRC bash :evel never
   "$gem5_repo"/util/term/m5term localhost 3456
   #+END_SRC

   Inside the =telnet= session, you can issue these two commands to access to
   the Spectre binary:

   #+BEGIN_SRC bash
   mkdir -p workload
   # /dev/vdb1 correspond to the image given with the --fs-workload option.
   mount /dev/vdb1 ./workload
   #+END_SRC

   And finally launch the Spectre attack inside the simulated system:

   #+BEGIN_SRC bash
   cd workload
   ./spectre -m 10 -l 100 -t 999
   #+END_SRC

   To extract your result from the simulation, you can either redirect them in
   a file on the mounted =workload.img= image, or copy-paste the terminal.
   
   When the Spectre attack will finish, you can terminate your
   simulation. Press =C-d= to disconnect from the terminal, and use the
   following command to kill gem5:

   #+BEGIN_SRC bash
   pkill gem5
   #+END_SRC

** How to Visualize the Pipeline of a gem5 Processor with Konata
   :PROPERTIES:
   :CUSTOM_ID: howto_konata
   :END:

   Konata is an external program allowing to see graphically the instructions
   executed in the pipeline of a simulated processor. The first thing to do is
   to download the pre-compiled binary from its [[https://github.com/shioyadan/Konata][official repository]]:

   #+BEGIN_SRC bash
   mkdir konata && cd konata
   konata_dir=$(pwd)/konata-linux-x64
   wget -O - 'https://github.com/shioyadan/Konata/releases/download/v0.34/konata-linux-x64.tar.gz' | tar -xz
   #+END_SRC

   In order to visualize the pipeline, you'll have to:
   1. Find which part of the simulation you want to see (otherwise the generated data will be too large),
   2. Run this part of the simulation with specific flags,
   3. Open the generated data in Konata.
   
   Firstly, to determine which portion of the simulation you want to see with
   Konata, you'll have to run the simulation once without any special flag and
   stop it (with =C-c=) at the time where the interesting part is starting. For
   example, in our experiment, the interesting part is the core of the Spectre
   attack. A possibility is to put a =printf= in your code just before this
   part and stop the simulation when you see the output text.

   When stopping the simulation, you will see a message like this one:

   #+BEGIN_EXAMPLE
   Exiting @ tick 3266927000 because user interrupt received
   #+END_EXAMPLE

   Here, 3266927000 is the number of tick we want to start the monitoring of
   executed instruction. We will refer to it as src_bash[:eval never :exports
   code]{$ticknumber}.
   
   Then, you'll have to run a simulation with the =--debug-flags=O3PipeView
   --debug-file=pipeview.txt= flags passed to the gem5 binary and the
   =--debug-start=$ticknumber= set accordingly to the previous step:
   
   #+BEGIN_SRC bash :eval never
   "$gem5_repo"/build/ARM/gem5.opt -q \
               --debug-flags=O3PipeView --debug-file=pipeview.txt --debug-start=$ticknumber \
               "$reproduce_repo"/gem5/RPIv4.py -v --se
               "$reproduce_repo/spectre/spectre -l 100"
   #+END_SRC

   When the simulation is over (or when you stopped it because it past the last
   point of interest), you just have to launch the graphical interface of
   Konata by issuing the src_bash[:eval never :exports
   code]{"$konata_dir/konata"} command, click on =File= and search for the
   =pipeview.txt= file generated with gem5 in the simulation folder.

   Note that gem5 is able to output a large number of information from every
   element of the system. For instance, during our work, we used to trace
   instruction execution, which output the state of the processor along with
   the executed instruction, by using the "src_bash[:exports code :eval
   never]{--debug-flags=O3CPU,Exec}" flag for the gem5 binary. We also used the
   ="$gem5_repo"/util/tracediff= binary, which allows to navigate in a =diff=
   view of the instructions executed between two simulation with different
   parameters, with this command:

   #+BEGIN_SRC bash
   "$gem5_repo"/util/tracediff \
               "$gem5_repo"/build/ARM/gem5.opt -q --debug-flags=Exec,-ExecSymbol \
               "$gem5_repo"/configs/example/arm/starter_se.py \
               "\"$reproduce_repo/spectre/spectre -l 100\"|\"$reproduce_repo/spectre/spectre -l 50\""
   #+END_SRC

* Implementations

  Implementation details goes here.

** Spectre
   :PROPERTIES:
   :CUSTOM_ID: implem_spectre
   :END:
   
   Our implementation resides in the =spectre= directory of the repository:

   #+BEGIN_SRC bash :dir ../ :results output :exports results
   tree spectre
   #+END_SRC

   #+RESULTS:
   #+begin_example
   spectre
   ├── asm.c
   ├── asm.h
   ├── main.c
   ├── Makefile
   ├── perf.c
   ├── perf.h
   ├── spectre_pht_sa_ip.c
   ├── spectre_pht_sa_ip.h
   ├── util.c
   └── util.h

   0 directories, 10 files
   #+end_example

   It is composed of the following modules:
   - =asm= :: ARM assembly implementation.
   - =main= :: Orchestrate all the modules.
   - =perf= :: =perf_event= wrapper.
   - =spectre_pht_sa_ip= :: Spectre implementation (for the PHT-SA-IP
     version).
   - util :: Useful functions used across the binary.

   Note that:
   - There is a lot of comments into the code, don't hesitate to look at it to
     understands specific parts of the Spectre attack or the assembly
     instructions.

** gem5
   :PROPERTIES:
   :CUSTOM_ID: implem_gem5
   :END:

   # TODO The first boot is with a simple cpu, a restoration is with the full
   # CPU.
   
   To understand what the patch does and how it works, see our corresponding
   [[https://stackoverflow.com/questions/63988672/using-perf-event-with-the-arm-pmu-inside-gem5][StackOverflow post]] or our [[https://www.mail-archive.com/gem5-users@gem5.org/msg18401.html][ticket on the gem5 mailing list]].

* Appendices

  - If you are a gem5 user who experience some unresolved errors, you could
    check the [[https://pierreay.github.io/reproduce-spectre-gem5/gem5_errors.html#runtime][=docs/gem5_errors.html=]] file.
