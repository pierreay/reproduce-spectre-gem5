#+TITLE: Reproducing Spectre Attack with gem5, How To Do It Right?
#+AUTHOR: Pierre Ayoub
#+EMAIL: pierre.ayoub@eurecom.fr
#+LANGUAGE: en
#+PROPERTY: header-args :eval never-export
#+HTML_HEAD: <link rel="stylesheet" href="https://sandyuraz.com/styles/org.min.css">

* Introduction

  This web page is linked to the /[[https://github.com/pierreay/reproduce-spectre-gem5/blob/main/docs/paper.pdf][Reproducing Spectre Attack with gem5, How To
  Do It Right?]]/ paper, as well with the /[[https://github.com/pierreay/reproduce-spectre-gem5/blob/main/docs/master_thesis.pdf][Simulating Transient Execution Attacks
  with gem5]]/ master thesis.

  It will guide you through the reproduction of the experiments, the usage of
  our implementations or through the demonstration of some techniques discussed
  in the paper. You can navigate with the table of content, or directly click
  below to:
  - [[#howto_spectre][Learn how to perform a Spectre attack with our implementation]]
  - [[#howto_spectre][Learn how to simulate Spectre with gem5]]
  - [[#howto_konata][Learn how to visualize the pipeline of a simulated processor with Konata]]

* Repository

  This web page is part of the repository located [[https://github.com/pierreay/reproduce-spectre-gem5][here]]. See the =README.md=
  file for repository organization and navigation.

* HowTo

** How to Setup the Native ARM System
   :PROPERTIES:
   :CUSTOM_ID: setup_arm
   :END:

   To reproduce this work, you will need:
   - An ARM board. We used a [[https://static.raspberrypi.org/files/product-briefs/200521+Raspberry+Pi+4+Product+Brief.pdf][Raspberry Pi v4 Model B Rev 1.1]] embedding a [[http://infocenter.arm.com/help/topic/com.arm.doc.100095_0003_06_en/cortex_a72_mpcore_trm_100095_0003_06_en.pdf][ARM
     Cortex-A72]] (ARMv8-A) processor implemented in a SoC [[https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711/rpi_DATA_2711_1p0.pdf][Broadcom BCM2711]].
   - A 64-bit operating system (kernel and userland) for ARM. We used [[https://www.offensive-security.com/kali-linux-arm-images/][Kali
     Linux]] (stable v2020.2a, with a Linux kernel v4.19.118-Re4son-v8l+ and a
     GCC compiler v9.3), because:
     1. It is a full 64-bit operating system supporting ARM,
     2. The kernel is nearly the same as the one provided by gem5,
     3. The kernel sources and headers are available with =apt= (for developing
        kernel modules, if you do so).

   Install the Kali Linux distribution. First, download the image:

   #+BEGIN_SRC bash :eval never
   cd /tmp
   zip="kali.xz"
   img="kali.img"
   wget -O "$zip" https://images.offensive-security.com/arm-images/kali-linux-2020.2a-rpi3-nexmon-64.img.xz
   xzcat "$zip" > "$img"
   rm -f "$zip"
   #+END_SRC

   Then, insert your SD card in your computer, and make sure that device block
   name is correct (find it with =lsblk= and =umount= it if it has been
   automatically mounted). Bit-copy the image on the SD card:

   #+BEGIN_SRC bash :eval never
   sdcard=/dev/sdd
   sudo dd bs=4M if="$img" of="$sdcard" status=progress conv=fsync
   rm -f "$img"
   #+END_SRC

   Now, plug the SD card in the Raspberry Pi, plug an Ethernet cable and plug
   the power cable in it. Then, find the IP address associated to it and
   connect with the =kali= login and =kali= password:

   #+BEGIN_SRC bash
   ip="192.168.1.1" # Find the correct IP.
   ssh kali@$ip
   # We install the following software:
   sudo apt-get update && sudo apt-get upgrade
   sudo apt-get -y install linux-cpupower git
   #+END_SRC

   You can log in the =root= account by issuing the command =sudo su root= if
   needed.

   You are now ready to reproduce Spectre on the Raspberry Pi.
   
** How to Perform the Spectre Attack
   :PROPERTIES:
   :CUSTOM_ID: howto_spectre
   :END:

   We assume that you are on the ARM system described in Section [[#setup_arm]] or
   an equivalent one.

   First, clone the repository:

   #+BEGIN_SRC bash :eval never
   git clone https://github.com/pierreay/reproduce-spectre-gem5
   # We will use this variable to designate the repository through the hole file.
   reproducing_repo="$(pwd)/reproduce-spectre-gem5"
   cd "$reproducing_repo"
   #+END_SRC

   Simply use the =Makefile= to compile our implementation, described in
   Section [[#implem_spectre]]:
    
   #+BEGIN_SRC bash :eval never
   cd spectre && make
   #+END_SRC

   Test if the binary is working by displaying a useful help message:

   #+BEGIN_SRC bash :eval never
   ./spectre --help
   #+END_SRC

   #+BEGIN_EXAMPLE
   Usage: spectre [OPTION...]
   Spectre -- A Spectre implementation useful for research

     -c, --cache_threshold=NUMBER   Cache threshold separating hit and miss
                                (default: automatically computed)
     -l, --loops=NUMBER         Number of loops (training and attack) per attempts
                                (default: 30)
     -m, --meta=NUMBER          Number of meta-repetition of Spectre (default: 1)
     -q, -s, --quiet, --silent  Don't produce the header for csv
     -t, --tries=NUMBER         Number of attempts to guess a secret byte
                                (default: 999)
     -v, --verbose              Produce verbose output
     -?, --help                 Give this help list
         --usage                Give a short usage message
     -V, --version              Print program version

   Mandatory or optional arguments to long options are also mandatory or optional
   for any corresponding short options.

   Report bugs to <pierre.ayoub@irisa.fr>.
   #+END_EXAMPLE
    
   And test the attack with the default parameters like this:

   #+BEGIN_SRC bash :eval never
   ./spectre 
   #+END_SRC

   If it works correctly, you surely want to generate the metrics as we do in
   the paper and customize some parameters. The metrics will be generated in a
   =csv= format, you can then redirect them to a file. To do so, we use this
   loop to repeat the hole experiment. We first launch one experiment, and
   relaunch the others with the =-q= flag to suppress header line:

   #+BEGIN_SRC bash :eval never
   # Parameters.
   runs=50 # Number of runs - 1.
   m=10    # Number of meta repetition in the binary itself.
   t=999   # Number of attempts to guess one byte.
   l=100   # Number of loop per attempt.
   # Runs.
   ./spectre/spectre -m $m -l $l -t $t
   for (( i = 1; i < $runs; i++ ))
   do  
       ./spectre/spectre -q -m $m -l $l -t $t   
   done
   #+END_SRC

   *Optional*. If you want to obtain the =perf_event= metrics under a gem5
   simulation, you will have to recompile the Spectre binary with a patch. This
   is still a =TODO= item in the source code. To do that, use =git-apply= to
   apply the patch, save the previously compiled binary with another name and
   relaunch =make=:

    #+BEGIN_SRC bash :eval never
    # Apply the patch
    cd "$reproduce_repo"
    git apply spectre/perf.c.patch
    # Save the previous binary
    cd spectre
    mv spectre spectre_native
    # Compile the new Spectre
    make
    #+END_SRC

    #+BEGIN_SRC diff :tangle ../spectre/perf.c.patch :exports none
    diff --git i/spectre/perf.c w/spectre/perf.c
    index 3b89ee7..c648e28 100644
    --- i/spectre/perf.c
    +++ w/spectre/perf.c
    @@ -39,9 +39,9 @@ static int perf_fd_branch_miss;
    static void perf_attr_init(struct perf_event_attr * attr, uint64_t config)
    {
    /* To use with real ARM hardware: */
    -    attr->type = PERF_TYPE_HARDWARE;
    +    // attr->type = PERF_TYPE_HARDWARE;
    /* To use with gem5 full-system ARM: */
    -    // attr->type = PERF_TYPE_RAW;
    +    attr->type = PERF_TYPE_RAW;
    attr->config = config;
    attr->size = sizeof(*attr);
    attr->exclude_kernel = 1;
    @@ -53,9 +53,9 @@ void perf_init() {
    /* Initialize our perf_event_attr, representing one counter to be read. */
    static struct perf_event_attr attr_cache_miss;
    /* To use with real ARM hardware: */
    -    perf_attr_init(&attr_cache_miss, PERF_COUNT_HW_CACHE_MISSES);
    +    // perf_attr_init(&attr_cache_miss, PERF_COUNT_HW_CACHE_MISSES);
    /* To use with gem5 full-system ARM: */
    -    // perf_attr_init(&attr_cache_miss, 0x33);
    +    perf_attr_init(&attr_cache_miss, 0x33);
    /* Open the file descriptor corresponding to this counter. The counter
    should start at this moment. */
    if ((perf_fd_cache_miss = syscall(__NR_perf_event_open, &attr_cache_miss, 0, -1, -1, 0)) == -1)
    @@ -64,8 +64,8 @@ void perf_init() {
    /* Same here. */
    static struct perf_event_attr attr_branch_miss;
    /* To use with real ARM hardware: */
    -    perf_attr_init(&attr_branch_miss,PERF_COUNT_HW_BRANCH_MISSES);
    +    // perf_attr_init(&attr_branch_miss,PERF_COUNT_HW_BRANCH_MISSES);
    /* To use with gem5 full-system ARM: */
    -    // perf_attr_init(&attr_branch_miss, 0x10);
    +    perf_attr_init(&attr_branch_miss, 0x10);
    if ((perf_fd_branch_miss = syscall(__NR_perf_event_open, &attr_branch_miss, 0, -1, -1, 0)) == -1)
    fprintf(stderr, "perf_event_open fail %d %d: %s\n", perf_fd_branch_miss, errno, strerror(errno));
    }
    #+END_SRC

** How to Setup gem5 for a Full-System Simulation
   :PROPERTIES:
   :CUSTOM_ID: howto_gem5_setup
   :END:

   To reproduce this work, you will need:
   - A working [[https://www.gem5.org/getting_started/][gem5]] installation. We used gem5 v20.0.
   - An [[https://www.gem5.org/documentation/general_docs/fullsystem/guest_binaries][operating system image and a kernel image]] ready-to-use with gem5. We
     used the [[http://dist.gem5.org/dist/current/arm/disks/linaro-minimal-aarch64.img.bz2][64-bit Linaro Minimal v7.4.0 (based on Ubuntu)]] and the [[http://dist.gem5.org/dist/current/arm/aarch-system-201901106.tar.bz2][ARM64
     Linux kernel v4.18.0]] images provided by gem5's developers.

   Note that this gem5 version and the images are now obsolete. You can of
   course follow our steps, but then for a new research, it would be better to
   use the latest gem5 version and images with the new recommended methods
   (e.g., Docker container).

   First, install the recommended packages:

   #+BEGIN_SRC bash :eval never
   sudo apt install build-essential git m4 scons zlib1g zlib1g-dev \
       libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev \
       python3-dev python3-six python libboost-all-dev pkg-config
   #+END_SRC

   Clone the gem5 repository:

   #+BEGIN_SRC bash :eval never
   git clone https://gem5.googlesource.com/public/gem5
   # We will use this variable to designate the gem5 repository through the hole
   # file.
   gem5_repo="$(pwd)/gem5"
   cd "$gem5_repo"
   #+END_SRC

   Checkout the commit for version 20.0:

   #+BEGIN_SRC bash :eval never
   git checkout v20.0.0.0
   #+END_SRC

   *Optional*. If you want to obtain the =perf_event= metrics under a gem5
   simulation, you will have to apply a patch from our repository to the gem5
   source code to enable =perf_event= on the gem5 side (note that it should not
   be required on the latest gem5 version). To do that, use:

   #+BEGIN_SRC bash
   git apply "$reproduce_repo/gem5/perf_event.patch"
   #+END_SRC

   #+BEGIN_SRC diff :tangle ../gem5/perf_event.patch :exports none
   diff --git i/src/arch/arm/ArmISA.py w/src/arch/arm/ArmISA.py
   index 2641ec3fb..3d85c1b75 100644
   --- i/src/arch/arm/ArmISA.py
   +++ w/src/arch/arm/ArmISA.py
   @@ -36,6 +36,7 @@
   from m5.params import *
   from m5.proxy import *

   +from m5.SimObject import SimObject
   from m5.objects.ArmPMU import ArmPMU
   from m5.objects.ArmSystem import SveVectorLength
   from m5.objects.BaseISA import BaseISA
   @@ -49,6 +50,8 @@ class ArmISA(BaseISA):
   cxx_class = 'ArmISA::ISA'
   cxx_header = "arch/arm/isa.hh"

   +    generateDeviceTree = SimObject.recurseDeviceTree
   +
   system = Param.System(Parent.any, "System this ISA object belongs to")

   pmu = Param.ArmPMU(NULL, "Performance Monitoring Unit")
   diff --git i/src/arch/arm/ArmPMU.py w/src/arch/arm/ArmPMU.py
   index 047e908b3..58553fbf9 100644
   --- i/src/arch/arm/ArmPMU.py
   +++ w/src/arch/arm/ArmPMU.py
   @@ -40,6 +40,7 @@ from m5.params import *
   from m5.params import isNullPointer
   from m5.proxy import *
   from m5.objects.Gic import ArmInterruptPin
   +from m5.util.fdthelper import *

   class ProbeEvent(object):
   def __init__(self, pmu, _eventId, obj, *listOfNames):
   @@ -76,6 +77,17 @@ class ArmPMU(SimObject):

   _events = None

   +    def generateDeviceTree(self, state):
   +        node = FdtNode("pmu")
   +        node.appendCompatible("arm,armv8-pmuv3")
   +        # gem5 uses GIC controller interrupt notation, where PPI interrupts
   +        # start to 16. However, the Linux kernel start from 0, and used a tag
   +        # (set to 1) to indicate the PPI interrupt type.
   +        node.append(FdtPropertyWords("interrupts", [
   +            1, int(self.interrupt.num) - 16, 0xf04
   +        ]))
   +        yield node
   +
   def addEvent(self, newObject):
   if not (isinstance(newObject, ProbeEvent)
   or isinstance(newObject, SoftwareIncrement)):
   diff --git i/src/cpu/BaseCPU.py w/src/cpu/BaseCPU.py
   index ab70d1d7f..66a49a038 100644
   --- i/src/cpu/BaseCPU.py
   +++ w/src/cpu/BaseCPU.py
   @@ -302,6 +302,11 @@ class BaseCPU(ClockedObject):
   node.appendPhandle(phandle_key)
   cpus_node.append(node)

   +        # Generate nodes from the BaseCPU children (and don't add them as
   +        # subnode). Please note: this is mainly needed for the ISA class.
   +        for child_node in self.recurseDeviceTree(state):
   +            yield child_node
   +
   yield cpus_node

   def __init__(self, **kwargs):
   #+END_SRC

   And finally, compile it in optimized mode (=opt=), for the ARM architecture
   (=ARM=), with 8 cores and for Python 3. It can take several hours:

   #+BEGIN_SRC bash :eval never
   mode="opt"
   arch="ARM"
   cores=8
   py_version=3 
   scons PYTHON_CONFIG=python$py_version-config build/$arch/gem5.$mode -j $cores
   #+END_SRC

    If everything is working, you should be able to display the help of one
    simulation script:

    #+BEGIN_SRC bash :eval never
    build/ARM/gem5.opt -q configs/example/arm/starter_fs.py --help   
    #+END_SRC

    Otherwise, check the [[https://pierreay.github.io/reproduce-spectre-gem5/gem5_errors.html#compilation][=docs/gem5_errors.html=]] file to see if the compilation
    error has already been encountered.
    
    Let's create the images you need to perform a full-system
    simulation. First, you have to download the operating system and the kernel
    images that you will use over our simulated hardware:

    #+BEGIN_SRC bash :eval never
    img_dir=img
    mkdir $img_dir && cd $img_dir
    # OS
    wget -O - http://dist.gem5.org/dist/current/arm/disks/linaro-minimal-aarch64.img.bz2 | bunzip2 > linaro-minimal-aarch64.img
    # Kernel
    wget -O - http://dist.gem5.org/dist/current/arm/aarch-system-201901106.tar.bz2 | tar xjv
    #+END_SRC

    Then, you will have to create a third =workload.img= image that will
    contain the file(s) that you want to use in your experiments. In order to
    do that, first create a 100MB zero file (you can change the size with the
    =count= parameter):

    #+BEGIN_SRC bash :eval never
    img=workload.img
    dd if=/dev/zero of=$img count=200K
    #+END_SRC

    Create a loopback device in order to access the image as a block device:

    #+BEGIN_SRC bash :eval never
    dev=$(sudo losetup -f)
    sudo losetup -fP $img
    #+END_SRC

    Create a DOS partition table and a primary partition on the entire image,
    then format the new created partition with the =ext4= file system:

    #+BEGIN_SRC bash :eval never
    echo "," | sudo sfdisk $dev
    sudo mke2fs "$dev"p1
    #+END_SRC
    
    Finally, you are done at modifying your image, detach it from the loopback
    device:

    #+BEGIN_SRC bash :eval never
    sudo losetup -d $dev
    #+END_SRC

    Now, you have a persistent file that will hold your files for the
    simulation. Define a function that will be used each time you need to
    update the image with new files (binaries, data...):

    #+BEGIN_SRC bash :eval never
    # $1: workload image name/path.
    # $*: list of files to copy.
    workload_update() {
        dev=$(sudo losetup -f)
        mnt=/mnt/workload
        # Get arguments.
        img="$1"
        shift
        # Create the mount folder and the loop device.
        sudo mkdir -p $mnt
        sudo losetup -fP "$img"
        # Mount the block device.
        sudo mount -o loop $dev $mnt
        # Copy files/folders.
        sudo cp -r -f -t $mnt $*
        # List the files to confirm.
        ls -alh $mnt
        # Unmount the image and freed the loop device.
        sudo umount $mnt
        sudo losetup -d $dev
    }
    #+END_SRC

    We will use this function later. All your 3 images will be mounted directly
    in the simulated system by gem5 itself, and the files in the workload image
    will be accessible in read/write. This is an efficient and handy way to
    communicate with a gem5 simulation.

** How to Simulate Spectre with gem5
   :PROPERTIES:
   :CUSTOM_ID: howto_gem5
   :END:

   We assume that you are able to compile and know how to perform a Spectre
   attack with our binary (at least in theory), described in Section
   [[#howto_spectre]].

   We assume that your gem5 setup is ready to perform a full-system simulation,
   described in Section [[#howto_gem5_setup]].

   The first step is to copy the Spectre binary on the =workload.img=
   image. Use our predefined function for that:

   #+BEGIN_SRC bash :eval never
   cd "$reproduce_repo"
   workload_update "$gem5_repo/$img_dir/$img" spectre/spectre
   #+END_SRC

   Then, we will launch the simulation of our system, described in Section
   [[#implem_gem5]], with gem5:

   #+BEGIN_SRC bash :eval never
   cd gem5
   #+END_SRC

** How to Visualize the Pipeline of a gem5 Processor with Konata
   :PROPERTIES:
   :CUSTOM_ID: howto_konata
   :END:

* Implementations

  Implementation details goes here.

** Spectre
   :PROPERTIES:
   :CUSTOM_ID: implem_spectre
   :END:
   
   Our implementation resides in the =spectre= directory of the repository:

   #+BEGIN_SRC bash :dir ../ :results output :exports results
   tree spectre
   #+END_SRC

   #+RESULTS:
   #+begin_example
   spectre
   ├── asm.c
   ├── asm.h
   ├── main.c
   ├── Makefile
   ├── perf.c
   ├── perf.h
   ├── spectre_pht_sa_ip.c
   ├── spectre_pht_sa_ip.h
   ├── util.c
   └── util.h

   0 directories, 10 files
   #+end_example

   It is composed of the following modules:
   - =asm= :: ARM assembly implementation.
   - =main= :: Orchestrate all the modules.
   - =perf= :: =perf_event= wrapper.
   - =spectre_pht_sa_ip= :: Spectre implementation (for the PHT-SA-IP
     version).
   - util :: Useful functions used across the binary.

   Note that:
   - There is a lot of comments into the code, don't hesitate to look at it to
     understands specific parts of the Spectre attack or the assembly
     instructions.

** gem5
   :PROPERTIES:
   :CUSTOM_ID: implem_gem5
   :END:

   # TODO The first boot is with a simple cpu, a restoration is with the full
   # CPU.
   
   To understand what the patch does and how it works, see our corresponding
   [[https://stackoverflow.com/questions/63988672/using-perf-event-with-the-arm-pmu-inside-gem5][StackOverflow post]] or our [[https://www.mail-archive.com/gem5-users@gem5.org/msg18401.html][ticket on the gem5 mailing list]].

* Appendices

  - If you are a gem5 user who experience some unresolved errors, you could
    check the [[https://pierreay.github.io/reproduce-spectre-gem5/gem5_errors.html#runtime][=docs/gem5_errors.html=]] file.
