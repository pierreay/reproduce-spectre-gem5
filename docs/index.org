#+TITLE: Reproducing Spectre Attack with gem5, How To Do It Right?
#+AUTHOR: Pierre Ayoub
#+EMAIL: pierre.ayoub@eurecom.fr
#+LANGUAGE: en
#+PROPERTY: header-args :eval never-export
#+HTML_HEAD: <link rel="stylesheet" href="https://sandyuraz.com/styles/org.min.css">

* Introduction

  This web page is linked to the /[[https://github.com/pierreay/reproduce-spectre-gem5/blob/main/docs/paper.pdf][Reproducing Spectre Attack with gem5, How To
  Do It Right?]]/ paper, as well with the /[[https://github.com/pierreay/reproduce-spectre-gem5/blob/main/docs/master_thesis.pdf][Simulating Transient Execution Attacks
  with gem5]]/ master thesis.

  It will guide you through the reproduction of the experiments, the usage of
  our implementations or through the demonstration of some techniques discussed
  in the paper. You can navigate with the table of content, or directly click
  below to:
  - [[#howto_spectre][Learn how to perform a Spectre attack with our implementation]]
  - [[#howto_spectre][Learn how to simulate Spectre with gem5]]
  - [[#howto_konata][Learn how to visualize the pipeline of a simulated processor with Konata]]

* Repository

  This web page is part of the repository located [[https://github.com/pierreay/reproduce-spectre-gem5][here]]. See the =README.md=
  file for repository organization and navigation.

* HowTo
  
** How to Perform the Spectre Attack
   :PROPERTIES:
   :CUSTOM_ID: howto_spectre
   :END:

   We assume that you cloned the repository on an ARM system, like a Raspberry
   Pi.

   Simply use the =Makefile= to compile our implementation:
    
   #+BEGIN_SRC bash :eval never
   cd spectre
   make
   #+END_SRC

   Test if the binary is working by displaying a useful help message:

   #+BEGIN_SRC bash :eval never
   ./spectre --help
   #+END_SRC

   #+BEGIN_EXAMPLE
   Usage: spectre [OPTION...]
   Spectre -- A Spectre implementation useful for research

     -c, --cache_threshold=NUMBER   Cache threshold separating hit and miss
                                (default: automatically computed)
     -l, --loops=NUMBER         Number of loops (training and attack) per attempts
                                (default: 30)
     -m, --meta=NUMBER          Number of meta-repetition of Spectre (default: 1)
     -q, -s, --quiet, --silent  Don't produce the header for csv
     -t, --tries=NUMBER         Number of attempts to guess a secret byte
                                (default: 999)
     -v, --verbose              Produce verbose output
     -?, --help                 Give this help list
         --usage                Give a short usage message
     -V, --version              Print program version

   Mandatory or optional arguments to long options are also mandatory or optional
   for any corresponding short options.

   Report bugs to <pierre.ayoub@irisa.fr>.
   #+END_EXAMPLE
    
   And test the attack with the default parameters like this:

   #+BEGIN_SRC bash :eval never
   ./spectre 
   #+END_SRC

   If it works correctly, you surely want to generate the metrics as we do in
   the paper and customize some parameters. The metrics will be generated in a
   =csv= format, you can then redirect them to a file. To do so, we use this
   loop to repeat the hole experiment. We first launch one experiment, and
   relaunch the others with the =-q= flag to suppress header line:

   #+BEGIN_SRC bash :eval never
   # Parameters.
   runs=50 # Number of runs - 1.
   m=10    # Number of meta repetition in the binary itself.
   t=999   # Number of attempts to guess one byte.
   l=100   # Number of loop per attempt.
   # Runs.
   ./spectre/spectre -m $m -l $l -t $t
   for (( i = 1; i < $runs; i++ ))
   do  
       ./spectre/spectre -q -m $m -l $l -t $t   
   done
   #+END_SRC

   Later, if you want to generate the metrics on gem5, you will have to
   recompile the binary with the following patch (remind to save the previously
   compiled binary). Use src_bash[:eval never :exports code]{git apply
   spectre/perf.c.patch} or comment/uncomment the few lines yourself (this is
   still a =TODO= item in the source code):

   #+BEGIN_SRC diff :tangle ../spectre/perf.c.patch
   diff --git i/spectre/perf.c w/spectre/perf.c
   index 3b89ee7..c648e28 100644
   --- i/spectre/perf.c
   +++ w/spectre/perf.c
   @@ -39,9 +39,9 @@ static int perf_fd_branch_miss;
    static void perf_attr_init(struct perf_event_attr * attr, uint64_t config)
    {
        /* To use with real ARM hardware: */
   -    attr->type = PERF_TYPE_HARDWARE;
   +    // attr->type = PERF_TYPE_HARDWARE;
        /* To use with gem5 full-system ARM: */
   -    // attr->type = PERF_TYPE_RAW;
   +    attr->type = PERF_TYPE_RAW;
        attr->config = config;
        attr->size = sizeof(*attr);
        attr->exclude_kernel = 1;
   @@ -53,9 +53,9 @@ void perf_init() {
        /* Initialize our perf_event_attr, representing one counter to be read. */
        static struct perf_event_attr attr_cache_miss;
        /* To use with real ARM hardware: */
   -    perf_attr_init(&attr_cache_miss, PERF_COUNT_HW_CACHE_MISSES);
   +    // perf_attr_init(&attr_cache_miss, PERF_COUNT_HW_CACHE_MISSES);
        /* To use with gem5 full-system ARM: */
   -    // perf_attr_init(&attr_cache_miss, 0x33);
   +    perf_attr_init(&attr_cache_miss, 0x33);
        /* Open the file descriptor corresponding to this counter. The counter
           should start at this moment. */
        if ((perf_fd_cache_miss = syscall(__NR_perf_event_open, &attr_cache_miss, 0, -1, -1, 0)) == -1)
   @@ -64,8 +64,8 @@ void perf_init() {
        /* Same here. */
        static struct perf_event_attr attr_branch_miss;
        /* To use with real ARM hardware: */
   -    perf_attr_init(&attr_branch_miss,PERF_COUNT_HW_BRANCH_MISSES);
   +    // perf_attr_init(&attr_branch_miss,PERF_COUNT_HW_BRANCH_MISSES);
        /* To use with gem5 full-system ARM: */
   -    // perf_attr_init(&attr_branch_miss, 0x10);
   +    perf_attr_init(&attr_branch_miss, 0x10);
        if ((perf_fd_branch_miss = syscall(__NR_perf_event_open, &attr_branch_miss, 0, -1, -1, 0)) == -1)
            fprintf(stderr, "perf_event_open fail %d %d: %s\n", perf_fd_branch_miss, errno, strerror(errno));
    }
   #+END_SRC
    
** How to Simulate Spectre with gem5
   :PROPERTIES:
   :CUSTOM_ID: howto_gem5
   :END:

** How to Visualize the Pipeline of a gem5 Processor with Konata
   :PROPERTIES:
   :CUSTOM_ID: howto_konata
   :END:

* Implementations

  Implementation details goes here.

** Spectre
   
   Our implementation resides in the =spectre= directory of the repository:

   #+BEGIN_SRC bash :dir ../ :results output :exports results
   tree spectre
   #+END_SRC

   #+RESULTS:
   #+begin_example
   spectre
   ├── asm.c
   ├── asm.h
   ├── main.c
   ├── Makefile
   ├── perf.c
   ├── perf.h
   ├── spectre_pht_sa_ip.c
   ├── spectre_pht_sa_ip.h
   ├── util.c
   └── util.h

   0 directories, 10 files
   #+end_example

   It is composed of the following modules:
   - =asm= :: ARM assembly implementation.
   - =main= :: Orchestrate all the modules.
   - =perf= :: =perf_event= wrapper.
   - =spectre_pht_sa_ip= :: Spectre implementation (for the PHT-SA-IP
     version).
   - util :: Useful functions used across the binary.

   Note that:
   - There is a lot of comments into the code, don't hesitate to look at it to
     understands specific parts of the Spectre attack or the assembly
     instructions.

** gem5
   
* Appendices

  - If you are a gem5 user who experience some unresolved errors, you could see
    the [[https://pierreay.github.io/reproduce-spectre-gem5/gem5_errors.html][=docs/gem5_errors.html=]] file.
